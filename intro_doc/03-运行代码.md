# 运行代码指南

本文档详细介绍如何使用 SandboxFusion 执行各种编程语言的代码。

---

## 支持的编程语言

SandboxFusion 支持 30+ 种编程语言和执行模式：

### 编译型语言

| 语言 | 标识符 | 说明 |
|------|--------|------|
| C++ | `cpp` | 标准 C++ 编译执行 |
| Go | `go` | Go 编译执行 |
| Go Test | `go_test` | Go 测试模式 |
| Java | `java` | Java 编译执行 |
| JUnit | `junit` | Java JUnit 测试 |
| C# | `csharp` | .NET C# 编译执行 |
| Rust | `rust` | Rust 编译执行 |
| Kotlin | `kotlin_script` | Kotlin 脚本模式 |
| Swift | `swift` | Swift 编译执行 |
| Scala | `scala` | Scala 编译执行 |
| D | `D_ut` | D 语言执行 |

### 脚本语言

| 语言 | 标识符 | 说明 |
|------|--------|------|
| Python | `python` | 标准 Python 执行 |
| pytest | `pytest` | Python 测试模式 |
| Node.js | `nodejs` | JavaScript 执行 |
| TypeScript | `typescript` | TypeScript 执行 |
| Jest | `jest` | JavaScript 测试模式 |
| PHP | `php` | PHP 执行 |
| Ruby | `ruby` | Ruby 执行 |
| Lua | `lua` | Lua 执行 |
| R | `R` | R 语言执行 |
| Perl | `perl` | Perl 执行 |
| Julia | `julia` | Julia 执行 |
| Racket | `racket` | Racket 执行 |

### 特殊类型

| 语言 | 标识符 | 说明 |
|------|--------|------|
| Jupyter | - | Jupyter Notebook 模式 |
| CUDA | `cuda` | CUDA GPU 代码 |
| Python GPU | `python_gpu` | Python GPU 模式 |
| Verilog | `verilog` | 硬件描述语言 |
| Lean | `lean` | Lean 4 定理证明 |
| SQL | `sql` | SQL 查询 |
| Bash | `bash` | Shell 脚本 |

---

## 基础代码执行

### 请求参数

```python
from sandbox_fusion import RunCodeRequest

request = RunCodeRequest(
    code='...',                    # 代码字符串（必需）
    language='python',             # 编程语言（必需）
    compile_timeout=10,            # 编译超时（秒，默认 10）
    run_timeout=10,                # 运行超时（秒，默认 10）
    memory_limit_MB=-1,            # 内存限制（MB，-1 无限制）
    stdin='input data',            # 标准输入（可选）
    files={},                      # 上传文件（可选）
    fetch_files=[]                 # 获取文件（可选）
)
```

### 响应结构

```python
class RunCodeResponse:
    status: str                    # 'Success' | 'Failed' | 'SandboxError'
    compile_result: CommandRunResult  # 编译结果（可能为 None）
    run_result: CommandRunResult      # 运行结果
    files: Dict[str, str]            # 获取的文件（base64 编码）

class CommandRunResult:
    status: str                    # 'Finished' | 'Error' | 'TimeLimitExceeded'
    execution_time: float          # 执行时间（秒）
    return_code: int               # 返回码
    stdout: str                    # 标准输出
    stderr: str                    # 标准错误
```

### 执行状态判断

| 状态 | 说明 |
|------|------|
| `Success` | 代码执行成功（返回码为 0） |
| `Failed` | 代码执行失败（返回码非 0 或超时） |
| `SandboxError` | 沙盒内部错误 |

### 示例：各语言执行

#### Python

```python
response = run_code(RunCodeRequest(
    code='''
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(10))
''',
    language='python'
))
print(response.run_result.stdout)  # 55
```

#### C++

```python
response = run_code(RunCodeRequest(
    code='''
#include <iostream>
using namespace std;

int main() {
    cout << "Hello from C++" << endl;
    return 0;
}
''',
    language='cpp'
))
print(response.run_result.stdout)  # Hello from C++
```

#### Go

```python
response = run_code(RunCodeRequest(
    code='''
package main

import "fmt"

func main() {
    fmt.Println("Hello from Go")
}
''',
    language='go'
))
print(response.run_result.stdout)  # Hello from Go
```

#### Java

```python
response = run_code(RunCodeRequest(
    code='''
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello from Java");
    }
}
''',
    language='java'
))
print(response.run_result.stdout)  # Hello from Java
```

#### Node.js

```python
response = run_code(RunCodeRequest(
    code='''
console.log("Hello from Node.js");
const arr = [1, 2, 3, 4, 5];
console.log("Sum:", arr.reduce((a, b) => a + b, 0));
''',
    language='nodejs'
))
print(response.run_result.stdout)
```

---

## Jupyter 模式

Jupyter 模式支持多个代码单元格的顺序执行，特别适合交互式数据分析和可视化。

### 请求参数

```python
from sandbox_fusion import RunJupyterRequest

request = RunJupyterRequest(
    cells=['cell1', 'cell2', ...],  # 代码单元格列表
    cell_timeout=10,                 # 单个 cell 超时（秒）
    total_timeout=45,                # 总超时（秒）
    memory_limit_MB=-1,              # 内存限制
    kernel='python3'                 # 内核类型
)
```

### 输出流说明

每个 cell 的执行结果包含四种输出流：

| 流类型 | 说明 | 示例 |
|--------|------|------|
| `stdout` | 标准输出 | `print()` 的输出 |
| `stderr` | 标准错误 | 警告信息、日志 |
| `display` | 富文本输出 | 图表、DataFrame、最后表达式的值 |
| `error` | 异常信息 | 未捕获异常的 traceback |

### 特殊功能

#### 1. 最后表达式自动输出

```python
response = run_jupyter(RunJupyterRequest(
    cells=[
        'a = 10',
        'a + 5'  # 自动输出到 display
    ]
))
# cells[1].display 将包含 "15"
```

#### 2. 图表自动捕获

```python
response = run_jupyter(RunJupyterRequest(
    cells=[
        'import matplotlib.pyplot as plt',
        'import numpy as np',
        'x = np.linspace(0, 10, 100)',
        'plt.plot(x, np.sin(x))',
        'plt.show()'
    ]
))
# 最后一个 cell 的 display 将包含 PNG 图片（base64 编码）
```

#### 3. 异常不中断执行

```python
response = run_jupyter(RunJupyterRequest(
    cells=[
        'a = 1',
        '1/0',           # 异常：不会中断后续 cell
        'print(a + 1)'   # 正常执行
    ]
))
# cells[1].error 包含 ZeroDivisionError
# cells[2].stdout 包含 "2"
```

### 完整示例

```python
from sandbox_fusion import run_jupyter, RunJupyterRequest
import base64

response = run_jupyter(RunJupyterRequest(
    cells=[
        # Cell 0: 导入库
        '''
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
''',
        # Cell 1: 创建数据
        '''
data = {
    'x': np.arange(10),
    'y': np.random.randn(10).cumsum()
}
df = pd.DataFrame(data)
df
''',
        # Cell 2: 绘图
        '''
plt.figure(figsize=(8, 4))
plt.plot(df['x'], df['y'], 'b-o')
plt.title('Random Walk')
plt.xlabel('Step')
plt.ylabel('Value')
plt.grid(True)
plt.show()
'''
    ],
    cell_timeout=30,
    total_timeout=60
))

# 检查每个 cell 的结果
for i, cell in enumerate(response.cells):
    print(f"\n=== Cell {i} ===")
    if cell.stdout:
        print(f"stdout: {cell.stdout[:100]}...")
    if cell.display:
        print(f"display: {type(cell.display)}")
    if cell.error:
        print(f"error: {cell.error}")
```

---

## 文件上传和下载

### 上传文件

文件需要以 base64 编码后上传：

```python
import base64
from sandbox_fusion import run_code, RunCodeRequest

# 准备文件内容
file_content = "Hello, World!\nThis is a test file."
encoded_content = base64.b64encode(file_content.encode()).decode()

response = run_code(RunCodeRequest(
    code='''
with open('input.txt', 'r') as f:
    content = f.read()
print(content)
''',
    language='python',
    files={
        'input.txt': encoded_content  # 文件名: base64 内容
    }
))
print(response.run_result.stdout)
```

### 下载文件

使用 `fetch_files` 参数指定要获取的文件：

```python
response = run_code(RunCodeRequest(
    code='''
# 生成输出文件
with open('output.txt', 'w') as f:
    f.write('Generated content')

# 生成二进制文件
import pickle
data = {'key': 'value', 'numbers': [1, 2, 3]}
with open('data.pkl', 'wb') as f:
    pickle.dump(data, f)
''',
    language='python',
    fetch_files=['output.txt', 'data.pkl']
))

# 获取文件内容
for filename, content_b64 in response.files.items():
    content = base64.b64decode(content_b64)
    print(f"{filename}: {len(content)} bytes")
```

### 路径规则

- **相对路径**：相对于临时目录（`/tmp/tmpxxxx`）
- **绝对路径**：可以指定绝对路径如 `/tmp/flag.txt`
- **自动创建目录**：如果目录不存在会自动创建

```python
# 使用子目录
response = run_code(RunCodeRequest(
    code='''
import os
os.makedirs('data/output', exist_ok=True)
with open('data/output/result.txt', 'w') as f:
    f.write('nested file')
''',
    language='python',
    fetch_files=['data/output/result.txt']
))
```

---

## 超时和内存限制

### 超时设置

```python
response = run_code(RunCodeRequest(
    code='...',
    language='python',
    compile_timeout=30,  # 编译超时 30 秒
    run_timeout=60       # 运行超时 60 秒
))
```

**超时状态判断**：

```python
if response.run_result.status == 'TimeLimitExceeded':
    print("执行超时")
```

### 内存限制

```python
response = run_code(RunCodeRequest(
    code='...',
    language='python',
    memory_limit_MB=512  # 限制 512 MB 内存
))
```

**注意**：`memory_limit_MB=-1` 表示不限制内存（默认值）。

---

## 标准输入

为程序提供标准输入：

```python
response = run_code(RunCodeRequest(
    code='''
name = input("Enter your name: ")
age = input("Enter your age: ")
print(f"Hello {name}, you are {age} years old!")
''',
    language='python',
    stdin='Alice\n25\n'  # 提供两行输入
))
print(response.run_result.stdout)
```

对于竞赛编程（读取多行输入）：

```python
response = run_code(RunCodeRequest(
    code='''
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        sum += x;
    }
    cout << sum << endl;
    return 0;
}
''',
    language='cpp',
    stdin='5\n1 2 3 4 5\n'
))
print(response.run_result.stdout)  # 15
```

---

## 测试框架

### pytest (Python)

```python
response = run_code(RunCodeRequest(
    code='''
def add(a, b):
    return a + b

def test_add():
    assert add(1, 2) == 3
    assert add(-1, 1) == 0
    assert add(0, 0) == 0
''',
    language='pytest'
))
print(response.run_result.stdout)  # pytest 输出
```

### Jest (JavaScript)

```python
response = run_code(RunCodeRequest(
    code='''
function sum(a, b) {
    return a + b;
}

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
''',
    language='jest'
))
```

### JUnit (Java)

```python
response = run_code(RunCodeRequest(
    code='''
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class MainTest {
    @Test
    void testAddition() {
        assertEquals(3, 1 + 2);
    }
}
''',
    language='junit'
))
```

### go test (Go)

```python
response = run_code(RunCodeRequest(
    code='''
package main

import "testing"

func Add(a, b int) int {
    return a + b
}

func TestAdd(t *testing.T) {
    if Add(1, 2) != 3 {
        t.Error("Expected 3")
    }
}
''',
    language='go_test'
))
```

---

## 错误处理

### 编译错误

```python
response = run_code(RunCodeRequest(
    code='int main() { return }',  # 语法错误
    language='cpp'
))

if response.compile_result and response.compile_result.return_code != 0:
    print("编译错误:")
    print(response.compile_result.stderr)
```

### 运行时错误

```python
response = run_code(RunCodeRequest(
    code='print(1/0)',
    language='python'
))

if response.run_result.return_code != 0:
    print("运行时错误:")
    print(response.run_result.stderr)
```

### 沙盒错误

```python
if response.status == 'SandboxError':
    print("沙盒内部错误，请检查配置或联系管理员")
```

---

## 下一步

- [04-使用数据集.md](04-使用数据集.md) - 学习如何使用评估数据集
- [05-API参考.md](05-API参考.md) - 查看完整的 API 参考
