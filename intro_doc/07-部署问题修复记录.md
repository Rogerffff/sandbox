# SandboxFusion 部署问题修复记录

> 记录在 vast.ai 云端 GPU 服务器上部署 SandboxFusion 时遇到的问题及修复方案。
>
> 修复日期：2026-02-06

---

## 目录

1. [问题一：find_conda_root() 无法定位 Conda 安装路径](#问题一findconda_root-无法定位-conda-安装路径)
2. [问题二：SDK RunCodeRequest 缺少 memory_limit_MB 字段](#问题二sdk-runcoderequest-缺少-memory_limit_mb-字段)
3. [附录：环境激活注意事项](#附录环境激活注意事项)

---

## 问题一：find_conda_root() 无法定位 Conda 安装路径

### 现象

启动 SandboxFusion 服务后，评测脚本调用 `run_code` API 执行 Python 代码时，服务端日志报错：

```
Command 'bash -c "source Conda root directory not found./bin/activate sandbox-runtime && which python"'
returned non-zero exit status 1.
```

所有代码执行请求均失败。

### 根因分析

**涉及文件**：`sandbox/utils/common.py` → `find_conda_root()`

该函数从 `sys.executable`（当前 Python 解释器路径）开始**向上遍历目录树**，查找包含 `condabin` 子目录的祖先目录作为 Conda 根目录。

```python
# 原始逻辑
python_executable = sys.executable  # → /venv/sandbox-server/bin/python
current_dir = python_executable
while current_dir:
    if os.path.exists(os.path.join(current_dir, 'condabin')):
        return current_dir  # 找到 condabin → 返回 Conda 根目录
    current_dir = os.path.dirname(current_dir)
return "Conda root directory not found."  # 找不到 → 返回错误字符串
```

在 vast.ai 环境中：
- Conda 本体安装在 `/opt/miniforge3/`（`condabin` 在此目录下）
- Conda 环境却创建在 `/venv/sandbox-server/` 和 `/venv/sandbox-runtime/`（不在 `/opt/miniforge3/envs/` 下）

从 `/venv/sandbox-server/bin/python` 向上遍历：
```
/venv/sandbox-server/bin/python
/venv/sandbox-server/bin/
/venv/sandbox-server/
/venv/
/
→ 都没有 condabin → 返回 "Conda root directory not found."
```

这个**错误字符串**被拼入 shell 命令，导致命令执行失败：
```bash
source "Conda root directory not found./bin/activate" sandbox-runtime
```

**调用链路**：
```
run_code API
  → major.py: get_python_rt_env('sandbox-runtime')
    → common.py: find_conda_root()  # 返回错误字符串
    → subprocess.run(f'bash -c "source {find_conda_root()}/bin/activate sandbox-runtime && which python"')
    → 命令执行失败
```

### 修复方案

在 `find_conda_root()` 中增加回退逻辑：当向上遍历失败后，依次尝试：
1. `shutil.which('conda')` — 从 `conda` 可执行文件的路径推导 Conda 根目录
2. 检查常见安装路径 — `/opt/conda`、`/opt/miniforge3`、`/opt/miniconda3` 等

**修改文件**：`sandbox/utils/common.py`

```python
def find_conda_root():
    try:
        # ... 原有的向上遍历逻辑 ...

        if conda_root and os.path.isdir(conda_root):
            return conda_root

        # [新增] 回退：从 conda 可执行文件路径推导
        import shutil
        conda_bin = shutil.which('conda')
        if conda_bin:
            candidate = os.path.dirname(os.path.dirname(os.path.realpath(conda_bin)))
            if os.path.isdir(os.path.join(candidate, 'condabin')):
                return candidate

        # [新增] 回退：检查常见安装路径
        for candidate in ['/opt/conda', '/opt/miniforge3', '/opt/miniconda3',
                          os.path.expanduser('~/miniconda3'),
                          os.path.expanduser('~/miniforge3'),
                          os.path.expanduser('~/anaconda3')]:
            if os.path.isdir(os.path.join(candidate, 'condabin')):
                return candidate

        return "Conda root directory not found."
    except Exception as e:
        return f"An unexpected error occurred: {e}"
```

### 验证

```bash
source /opt/conda/bin/activate sandbox-server
python -c "from sandbox.utils.common import find_conda_root; print('Conda root:', find_conda_root())"
# 输出: Conda root: /opt/miniforge3
```

---

## 问题二：SDK RunCodeRequest 缺少 memory_limit_MB 字段

### 现象

评测脚本传递了 `memory_limit_MB=1024`，但 SandboxFusion 服务端日志始终显示：

```
start processing python request with code ```...``` and files []...(memory_limit: -1MB)
```

`-1` 表示无内存限制，说明客户端传递的内存限制参数被忽略了。

### 根因分析

涉及三个层面的不一致：

| 层面 | 文件 | `memory_limit_MB` 字段 |
|------|------|------------------------|
| **服务端** `RunCodeRequest` | `sandbox/server/sandbox_api.py` | ✅ 已定义 `memory_limit_MB: int = Field(-1)` |
| **SDK 客户端** `RunCodeRequest` | `scripts/client/src/sandbox_fusion/models.py` | ❌ **缺失** |
| **pip 安装后的 SDK** | `site-packages/sandbox_fusion/models.py` | ❌ **缺失** |

**SDK 客户端缺少 `memory_limit_MB` 字段**，这是一个遗漏/bug。

**数据流分析**：
```
评测脚本                        SDK 客户端                      SandboxFusion 服务端
RunCodeRequest(               → request.dict()               → POST /run_code
  memory_limit_MB=1024          序列化为 JSON                   服务端反序列化
)                               → Pydantic 丢弃未知字段          memory_limit_MB 使用默认值 -1
                                → JSON 中没有 memory_limit_MB
```

SDK 的 `run_code()` 函数（`scripts/client/src/sandbox_fusion/client.py`）通过 `request.dict()` 将 Pydantic 模型序列化为 JSON 发送给服务端。由于模型中没有定义 `memory_limit_MB` 字段，Pydantic 会**静默丢弃**这个参数，导致序列化后的 JSON 中不包含该字段，服务端使用默认值 `-1`。

### 修复方案

在 SDK 客户端的 `RunCodeRequest` 模型中补上缺失的字段。

**修改文件**：`scripts/client/src/sandbox_fusion/models.py`

```python
class RunCodeRequest(BaseModel):
    compile_timeout: float = Field(10, description='compile timeout for compiled languages')
    run_timeout: float = Field(10, description='code run timeout')
    memory_limit_MB: int = Field(-1, description='maximum memory allowed in megabytes')  # [新增]
    code: str = Field(..., examples=['print("hello")'], description='the code to run')
    stdin: Optional[str] = Field(None, examples=[''], description='optional string to pass into stdin')
    language: Language = Field(..., examples=['python'], description='the language or execution mode to run the code')
    files: Dict[str, Optional[str]] = Field({}, description='a dict from file path to base64 encoded file content')
    fetch_files: List[str] = Field([], description='a list of file paths to fetch after code execution')
```

### 重要提示：pip 安装的包需要同步修改

修改 SDK 源码后，**已通过 pip 安装到环境中的包不会自动更新**。Python 的 `pip install` 会将包**复制**到 `site-packages/` 目录下，后续修改源码不影响已安装版本。

需要额外修改已安装环境中的同名文件：

```bash
# 查看实际加载路径
python -c "import sandbox_fusion; print(sandbox_fusion.__file__)"
# 输出: /venv/main/lib/python3.12/site-packages/sandbox_fusion/__init__.py

# 直接修改已安装的版本（或重新 pip install）
vim /venv/main/lib/python3.12/site-packages/sandbox_fusion/models.py
```

### 验证

```bash
python -c "
from sandbox_fusion import RunCodeRequest
req = RunCodeRequest(code='print(1)', language='python', memory_limit_MB=1024)
print(req.dict().get('memory_limit_MB'))
"
# 输出: 1024
```

服务端日志应显示 `memory_limit: 1024MB`。

---

## 附录：环境激活注意事项

### vast.ai 容器的自动环境激活

vast.ai 容器的 `~/.bashrc` 末尾包含入口脚本：

```bash
cd ${WORKSPACE} && source /venv/${ACTIVE_VENV:-main}/bin/activate
```

这会在每次打开新 shell 时自动激活 `/venv/main` virtualenv。

**问题**：执行 `source /opt/conda/bin/activate sandbox-server` 后，虽然提示符变成了 `(sandbox-server)`，但 `/venv/main` 的 `VIRTUAL_ENV` 和 `PATH` 仍然优先生效，导致 `python` 实际指向 main 环境。

**正确的环境切换方式**：

```bash
# 方式 1：先 deactivate main，再用 conda shell hook 激活
deactivate 2>/dev/null
unset VIRTUAL_ENV
eval "$(/opt/miniforge3/bin/conda shell.bash hook)"
conda activate sandbox-server

# 方式 2：直接使用绝对路径
/venv/sandbox-server/bin/python -c "from sandbox.server.server import app; print('OK')"
```

### Conda 路径软链接

vast.ai 环境中 Conda 安装在 `/opt/miniforge3`，但许多文档默认使用 `/opt/conda`。建议创建软链接统一路径：

```bash
ln -s /opt/miniforge3 /opt/conda
export PATH="/opt/conda/bin:$PATH"
```
